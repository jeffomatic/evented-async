// Generated by CoffeeScript 1.6.2
(function() {
  var async, events, lib, _,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('underscore');

  async = require('async');

  events = require('events');

  lib = {
    timer: function(emitter, eventName, asyncFunc) {
      return function() {
        var args, done, startTime;

        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (_.isFunction(args[args.length - 1])) {
          done = args.pop();
        } else {
          done = null;
        }
        startTime = Date.now();
        return asyncFunc.apply(null, __slice.call(args).concat([function() {
          var results;

          results = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          emitter.emit.apply(emitter, [eventName, Date.now() - startTime].concat(__slice.call(results)));
          if (done) {
            return done.apply(null, results);
          }
        }]));
      };
    },
    profile: function() {
      var asyncFunc, asyncFuncArgs, emitter, eventName, timerFunc;

      emitter = arguments[0], eventName = arguments[1], asyncFunc = arguments[2], asyncFuncArgs = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
      timerFunc = lib.timer(emitter, eventName, asyncFunc);
      return timerFunc.apply(null, asyncFuncArgs);
    },
    Queue: (function(_super) {
      __extends(_Class, _super);

      function _Class(task, concurrency) {
        var _this = this;

        if (concurrency == null) {
          concurrency = 1;
        }
        this.q = async.queue(function(_arg, done) {
          var args;

          args = _arg.args;
          return task.apply(null, __slice.call(args).concat([done]));
        }, concurrency);
        this.q.saturated = function() {
          return _this.emit('saturated');
        };
        this.q.empty = function() {
          return _this.emit('empty');
        };
        this.q.drain = function() {
          return _this.emit('drain');
        };
      }

      _Class.prototype.push = function() {
        var args;

        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return this.q.push({
          args: args
        });
      };

      _Class.prototype.unshift = function() {
        var args;

        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return this.q.unshift({
          args: args
        });
      };

      _Class.prototype.length = function() {
        return this.q.length();
      };

      _Class.prototype.concurrency = function(concurrency) {
        if (concurrency != null) {
          return this.q.concurrency = concurrency;
        } else {
          return this.q.concurrency;
        }
      };

      return _Class;

    })(events.EventEmitter)
  };

  module.exports = lib;

}).call(this);
