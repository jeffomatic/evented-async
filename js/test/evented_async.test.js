// Generated by CoffeeScript 1.6.2
(function() {
  var assert, eventedAsync, events, sinon, testHelper;

  assert = require('assert');

  events = require('events');

  sinon = require('sinon');

  testHelper = require('./test_helper');

  eventedAsync = require('../lib/evented_async');

  describe('eventedAsync', function() {
    describe('.timer()', function() {
      beforeEach(function() {
        this.emitter = new events.EventEmitter;
        this.eventName = 'testEvent';
        return this.emitter.on(this.eventName, (this.eventSpy = sinon.spy()));
      });
      it('should broadcast events to the given emitter', function(done) {
        var timedFunc,
          _this = this;

        timedFunc = eventedAsync.timer(this.emitter, this.eventName, function(timedSecDone) {
          return timedSecDone();
        });
        return timedFunc(function() {
          assert(_this.eventSpy.calledOnce);
          return done();
        });
      });
      it('should give reasonable timings', function(done) {
        var timedFunc,
          _this = this;

        timedFunc = eventedAsync.timer(this.emitter, this.eventName, function(timedSecDone) {
          return setTimeout(function() {
            return timedSecDone();
          }, 50);
        });
        return timedFunc(function() {
          assert(_this.eventSpy.args[0][0] >= 50);
          return done();
        });
      });
      it('should pass return values through to the event listener', function(done) {
        var timedFunc,
          _this = this;

        timedFunc = eventedAsync.timer(this.emitter, this.eventName, function(timedSecDone) {
          return timedSecDone('testArg1', 'testArg2');
        });
        return timedFunc(function() {
          assert(_this.eventSpy.args[0][1] === 'testArg1');
          assert(_this.eventSpy.args[0][2] === 'testArg2');
          return done();
        });
      });
      return it('should pass return values through to the async function callback', function(done) {
        var timedFunc,
          _this = this;

        timedFunc = eventedAsync.timer(this.emitter, this.eventName, function(timedSecDone) {
          return timedSecDone('testArg1', 'testArg2');
        });
        return timedFunc(function(arg1, arg2) {
          assert(arg1 === 'testArg1');
          assert(arg2 === 'testArg2');
          return done();
        });
      });
    });
    describe('.profile()', function() {
      beforeEach(function() {
        this.emitter = new events.EventEmitter;
        this.eventName = 'testEvent';
        return this.emitter.on(this.eventName, (this.eventSpy = sinon.spy()));
      });
      it('should broadcast events to the given emitter', function(done) {
        var _this = this;

        return eventedAsync.profile(this.emitter, this.eventName, function(timedSecDone) {
          return timedSecDone();
        }, function() {
          assert(_this.eventSpy.calledOnce);
          return done();
        });
      });
      it('should give reasonable timings', function(done) {
        var _this = this;

        return eventedAsync.profile(this.emitter, this.eventName, function(timedSecDone) {
          return setTimeout(function() {
            return timedSecDone();
          }, 50);
        }, function() {
          assert(_this.eventSpy.args[0][0] >= 50);
          return done();
        });
      });
      it('should pass return values through to the event listener', function(done) {
        var _this = this;

        return eventedAsync.profile(this.emitter, this.eventName, function(timedSecDone) {
          return timedSecDone('testArg1', 'testArg2');
        }, function() {
          assert(_this.eventSpy.args[0][1] === 'testArg1');
          assert(_this.eventSpy.args[0][2] === 'testArg2');
          return done();
        });
      });
      it('should pass return values through to the async function callback', function(done) {
        var _this = this;

        return eventedAsync.profile(this.emitter, this.eventName, function(timedSecDone) {
          return timedSecDone('testArg1', 'testArg2');
        }, function(arg1, arg2) {
          assert(arg1 === 'testArg1');
          assert(arg2 === 'testArg2');
          return done();
        });
      });
      return it('should pass the given arguments to the async functions', function(done) {
        return eventedAsync.profile(this.emitter, this.eventName, function(arg1, arg2, timedSecDone) {
          assert(arg1 === 'testArg1');
          assert(arg2 === 'testArg2');
          return timedSecDone();
        }, 'testArg1', 'testArg2', done);
      });
    });
    return describe('Queue class', function() {
      it('should forward arugments to the wrapped task function', function(done) {
        var q, receivedArg1, receivedArg2, task, testArg1, testArg2;

        receivedArg1 = null;
        receivedArg2 = null;
        task = function(arg1, arg2, taskDone) {
          receivedArg1 = arg1;
          receivedArg2 = arg2;
          return process.nextTick(taskDone);
        };
        testArg1 = 'arg1';
        testArg2 = 'arg2';
        q = new eventedAsync.Queue(task);
        q.on('drain', function() {
          assert.equal(testArg1, receivedArg1);
          assert.equal(testArg2, receivedArg2);
          return done();
        });
        return q.push(testArg1, testArg2);
      });
      return it('should wait until all exceptions have been handled', function(done) {
        var q, task, tasksDoneCount,
          _this = this;

        tasksDoneCount = 0;
        task = function(taskDone) {
          tasksDoneCount += 1;
          return setTimeout(taskDone, 10);
        };
        q = new eventedAsync.Queue(task);
        q.once('drain', function() {
          assert.equal(tasksDoneCount, 3);
          return done();
        });
        setTimeout((function() {
          return q.push();
        }), 5);
        setTimeout((function() {
          return q.push();
        }), 10);
        setTimeout((function() {
          return q.push();
        }), 15);
        return setTimeout((function() {
          return q.push();
        }), 50);
      });
    });
  });

}).call(this);
